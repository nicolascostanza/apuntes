APUNTE ---- 03

* ETIQUETAS HTML ---> estan delimitadas por '<' and '>' symbols. Son insensitive, osea q no diferencian entre mayusculas y minusculas. Usualmente son usadas de a pares con <> opening tags y closing tags. Tambien hay algunas etiquetas que tienen auto cerrado por no poseer contenido

* ELEMENTO HTML ---> es todo lo que esta rodeado entre las etiquetas de apertura y de cierre. Estas etiquetas pueden ser autocerradas en caso de que el contenido no sea requerido

* H1 ... H6 ETIQUETAS ---> solo debe usarse una vez el h1 por documento. Esto no es una regla pero es bueno para el renderizado de la pantalla y el SEO (posicionamiento en las busquedas, search engine optimization)

* ETIQUETA P ---> debe ser usada para definir parrafos

* ETIQUETA A ---> se usa para mostrar un link clickeable

* ETIQUETA IMG ---> se usa para renderizar imagenes en el documento html. La propiedad 'alt' debe contener una definicion para mostrar cuando la imagen definida en la propiedad 'src' esta rota

* COMPORTAMIENTO EN PANTALLA ---> Comunmente los elementos html tienen 2 tipos de valores para ser mostrados: 'inline' o 'block'
  - ELEMENTOS EN BLOQUE ---> Un elemento en bloque siempre empieza en una linea nueva. Y el navegador agrega automaticamente algo de espacio(margen) antes y despues del elemento. Estos toman todo el ancho disponible. Ejemplo de este tipo de elemento son las etiquetas: p, div, section, aside, header, ol, ul, li, main, nav, etc
  - ELEMENTOS EN LINEA ---> Estos elementos no empiezan al principio de una nueva linea. Empiezan en la misma linea que el ultimo elemento anterior a el y solo toma el ancho necesario. Algunas etiquetas que sirven de ejemplo son: span, img, button, select, a

* HTML DISEÑO RESPONSIVE ---> Un diseño de web responsive permitira a la pagina ser leida y mostrada bien en diferentes dispositivos. Desde medidas de telefono a computadoras de escritorio. Esto se realiza ajustando las medidas de cada elemento, reordenando, mostrando y ocultando elementos automaticamente cuando las dimensiones del dispositivo varien

* VIEWPORT META TAG ---> esta etiqueta va en el head del documento. Agregando esta etiqueta el navegador obtiene informacion sobre como manejar las dimensiones y las escalas. El viewport de un navegador es el area en donde el contenido puede ser visto. Cuando se renderiza y se desborda el viewport del navegador, este nos da unas barras de desplazamiento en la direccion necesaria. Es habitual que en telefonos o tables se rendericen las paginas con un tamaño mayor al debido. Entonces se baja la escala para que quede ajustada al viewport

* UNIDADES RESPONSIVAS Y METODOS ---> Algunas medidas estan bien utilizadas, como %, vw, vh, tambien propiedades como min-widht o max-widht son muy utiles. Para hacer elementos dinamicos. En el pasado se usaban media querys con dimensiones standar de pantallas para cambiar por completo la medida de un elemento. En la actualidad lo mas usado es flex-box y grid para hacer paginas dinamicas.

* CSS ---> Traducido es hojas de estilo en cascada. Describe como los elementos html deben ser mostrados. CSS puede reutilizar elementos html hasta incluso documentos, ahorrando mucho tiempo. CSS puede utilizarse para resolver problemas relacionado a las posiciones o dimensiones.

* SELECTORES ---> Se utilizan para elegir que elemento queres aplicarle estilos.
  - selectores simples ---> elige elementos basados en nombre, id o clase
  - selectores combinados ---> selecciona elementos basados en una relacion entre ellos
  - selectores de pseudo-clases ---> selecciona elementos en un cierto estado
  - selectores de pseudo-elementos ---> selecciona y estiliza una parte de un elemento
  - selectores de atributos ---> selecciona elementos basados en un atributo o el valor del atributo
  - '*' ---> es el selector universal. Selecciona a todos los elementos. Es util para darle un reset de margenes y padding a las paginas que ya traen por defecto en los navegadores.
  - selectores de grupos ---> poniendo una etiqueta, clase o id separados por una coma le damos le mismo estilo a todos

* COMBINADORES
  “ ” descendente
  > hijo
  ~ hermano
  + hermano adjunto

* PSEUDO SELECTORES
  * clases ---> .class:pseudo-class
  * elementos ---> element::pseudo-element

* BOX MODEL ---> es una caja que encierra a cada elemento html. Se divide en:
  - contenido: es el contenido que aparece dentro de la caja, como texto o imagenes
  - relleno (padding): es el espacio del borde de la caja para adentro, al darle mas empuja el contenido para adentro
  - borde: es el borde alrededor del padding y el contenido
  - margen: es el espacio desde el borde para afuera de la caja, es el espacio contra otros elementos

* BOX SIZING
  - box content ---> te da un comportamiento de cajas por defecto en css. Al darle un ancho le asigna todo el ancho al contenido, haciendo q medidas de margenes, paddings y bordes se le agreguen al final. Modificiando el tamaño
  - border box ---> el padding y el border pasan a formar parte del calculo del width o heigth establecido, no se lo agrega

* LAYOUT ---> el layout a menudo depende del target de los usuarios. El layout mas comun es 1 columna telefonos, 2 columnas tables, 3 columnas computadoras de escritorio. Arriba el header, en el medio el main y/o aside y abajo el footer

* ESPECIFICIDAD ---> es el grado de importancia q tiene cada elemento para asi css pueda aplicar la mas importante al html. Los estilos en linea siempre sobreescriben cualquier otro tipo de atributo ya ingresado por los tipos de especificidad siguiente.
  - ID ---> #esUnId
  - clase, atributos, pseudoclases ---> .esUnaClase | [type='radio'] | :hover
  - selectores de tipo, pseudo-elementos ---> h1 | ::before

* !important ---> usando la regla del !important sobreescribimos cualquier estilo. El uso de esto deberia evitarse ya que rompe el estilizado en cascada

* :is() and :not() and :where() ---> son pseudoclases

* MEDIAQUERYS ---> son utiles cuando queres modificar dependiendo del tipo general de dispositivo usado o especificar caracteristicas o parametros. Una mediaquery esta compuesta por:
  - opcional media tpye (all-default, screen, print)
  - expresiones de medias o relaciones de pantallas. Puedes combinar varias
  - operadores logicos (AND OR ONLY)
Si usamos el not o only, debemos especificar el type media. Las media querys son case-insensitive, osea q no diferencia entre mayusculas y minusculas.

* FLEXBOX ---> designa una dimension para el layout(x, y) y tiene metodos para la separacion entre sus elementos
  - axis ---> hay dos ejes, el eje principal y el eje cruzado o secundario. La direccion de estos ejes no es fija, se puede cambiar con flex-direction. Las opciones en flex-direction son row, row-reverse, column, column-reverse
  - flex container ---> es un area del documento html que le asignamos la propiedad display: flex o display: inline-flex. Despues de esto los elementos hijos se convierten en flex items y absorven las propiedades elegidas por el padre
  - flex-wrap ---> permite que cuando no caben mas en una linea (determinada por flex-direction) genera otra en esa misma direccion para ubicarlos ahi. Si hay mas de una linea se puede usar align-content para ajustar el espaciado y la ubicacion.
  - flex-flow ---> es un acortador que le asignas las propiedades flex-wrap y flex-direction juntas
  - propiedades del flex item (hijo del container con display flex)
    - flex basis ---> define la medida del elemento, si no lo tiene toma auto.
    - Flex Grow ---> cuanto va a crecer el item con respecto a los hermanos (por defectos todos son 1, pero se pueden modificar y el q tenga mas toma mas espacio en la escala)
    - flex Shrink ---> lo mismo q el grow pero en achicamiento
    * Para el crecimiento o el achicamiento la cuenta es la siguiente.
      1) se toman los flex-shirk o flex-grow de todos los hermanos y se los suma. Se lo pone como el denominador de la cuenta
      2) unidades propias de cada item / el total de unidades con la propiedad * el tamaño total a ocupar
      3) ejemplo: (2unidades / 5unidades) * ancho total
  - propiedad flex ---> acortador q toma los valores de las propiedades flex-grow, flex-shrink, flex-basis
    * inicial valores: 0 1 auto
    * auto: 1 1 auto
    * none: 0 0 auto
  - align items ---> ordena los hijos del container en el eje secundario. Las opciones son: stretch(default), flex-start, flex-end, center
  - justify content ---> ordena los hijos del container en el eje principal. las opciones son: flex-start(default), flex-end, center, space-around, space-evenly, space-between

* JAVASCRIPT ---> EL navegador pone a disposicion cuando la pagina carga el DOM. Este dom esta expuesto a todos los script que realicemos. Con esto javascript puede crear y modificar elementos haciendo que las paginas se sientan dinamicas y vivas. El DOM esta jerarquizado en un objeto, pareciendose a un arbol. Ademas podemos definir propiedades, metodos y eventos html. Formas basicas de manipular el DOM
  - method document.createElement(element)    - description Create an HTML element
  - method document.removeChild(element)      - description Remove an HTML element
  - method document.appendChild(element)      - description Add an HTML element
  - method document.replaceChild(new, old)    - description Replace an HTML element

* EVENT LISTENER ---> esto adjunta un evento a cualquier elemento del DOM.
  - Ejemplo: elementoLi.addEventListener(event, function)
  - para remover un evento: elementoLi.removeEventListener(event, function)

* PROPAGACION DE EVENTOS ---> al hacer algun evento en alguna parte del DOM se ejecuta primero el mas cercano y va creciendo hacia sus padres, asi funciona la propagacion

* UNDEFINED AND NULL EN CONTEXTO NUMERICO ---> undefined es mostrado como NaN (not a number, no es un numero) y null es mostrado como 0

* VARIABLES ---> se pueden declarar con const, let o var. Los nombres de las variables pueden iniciar con letras, '_', '$'. No se puede iniciar con numeros

* LET Y CONST ---> este tipo de declaracion viene desde ecmascript 6. Son de alcance local, y si se declaran en el ambito global(fuera de las funciones, osea que pueden ser usadas en cualquier parte del archivo script) no se añaden al objeto global
  - CONST ---> las constantes deben ser inicializadas y no pueden cambiar su valor. En el tipo objeto el 'pointer' osea cursor q apunta a la direccion de memoria no puede cambiarse pero si sus valores internos. Para hacer un objeto profundamente inmutable debemos usar Object.freeze() , este es un metodo superficial asique podemos 'congelar' las propiedades del objeto pero no la referencia al objeto en las propiedades.
  - LET ---> tienen un alcance local, relacionada al bloque en donde se definan. Pueden o no ser inicializadas. Es muy util para manejar variables privadas
  - VAR ---> la diferencia de var con let es que si definimos var afuera de cualquier funcion no podemos volver a definir una var con el mismo nombre dentro de la funcion, ya que se pisarian los valores pq tiene alcance global. A las variables declaradas con VAR se le agregan los objetos globales window or node, en cambio a let no. (con var podemos usar this.NombreVariable, con let no)

* ZONA MUERTA TEMPORAL ---> hace referencia al momento en el que inicia el script y las variables no estan definidas. La diferencia es que las variables una vez llegado el caso se declaren con var, antes de eso si la queremos usar nos devolvera undefined. En cambio las variables que llegado el momento se declaran con let si queremos acceder antes no dara un error de referencia. Esta zona antes de la declaracion de las variables es la (TDZ), zona muerta temporal. Las variables declaradas con let y const si no estan inicializadas no podes acceder, en cambio las variables declaradas con var y q no esten inicializadas toman el valor de undefined. Diferencia: error / undefined. Ademas si la funcion es declarada como function nombre variable (parametros) y llaves si te deja acceder antes de la escritura de la funcion. En cambio si ponemos const miVariable = una funcion, y queremos ejecutar miVariable() antes de q fue escrita te da error

* TIPADO EN JAVASCRIPT ---> javascript es un lenguaje de tipado dinamico. Esto significa que no tenemos que especificarle el tipo de dato al declarar la variable y que ademas puede cambiar de un tipo de dato a otro en la ejecucion del programa

* ARRAYS LITERALES Y GIT ---> la coma al final del ultimo elemento del array no hace que cambie nada. Y ademas eso ayuda a git a mantener los diff limpios ya que cuando agregamos un elemento no modifica la ultima linea sino que solo agregamos una mas

* DECLARACION DE ENTEROS ---> tipos de enteros:
  - Un 0 (cero) inicial en un literal entero, o un 0o (o 0O) inicial indica que está en octal. Octal sólo pueden incluir los dígitos 0-7
  - Un 0x (o 0X) inicial indica un literal entero hexadecimal. Los enteros hexadecimales pueden incluir dígitos (0-9) y las letras a-f y A-F
  - Un 0b inicial (o 0B) indica un literal entero binario. Los literales enteros binarios sólo pueden incluir los dígitos 0 y 1.
  - Un sufijo n al final de un literal entero indica que se trata de un literal BigInt. El literal entero puede utilizar cualquiera de las bases anteriores

* DECLARACIONES DE FLUJO DE CONTROL ---> son los que hacen variar o modifican el linea a linea del codigo. Existen varios de ellos. Los condicionales (if, switch), los loops o bucles (while, for), y las funciones.

* FALSY VALUES ---> Estos valores dan falso en expresion logicas:
  - false
  - undefined
  - null
  - 0
  - NaN
  - string vacio ("")

* SWITCH ---> el caso por defecto y el break son opcionales. Si no se pone el caso por defecto y no se matchea con ningun caso no se hace nada. El caso por defecto no es necesario tenerlo al final aunque es buena practica ponerlo ahi. Si se omiten los break en los casos, una vez q matchee en un caso seguira ejecutando lo siguientes tambien.

* EXCEPCIONES ---> son condiciones que interrumpen el flujo normal del programa. Se pueden generar y enviar con la sentencia throw. La buena practica dice que hay que instanciar un nuevo Error. Ejemplo:
  - throw new Error('El mensaje que quiero enviar para el error')

* TRY / CATCH / FINALLY ---> JavaScript crea un identificador vinculado a la excepción que se lanzó antes de entrar en el bloque. En el ejemplo anterior es el identificador ex (No tiene regla de nomenclatura pero es una buena convención usar ex, err, o error). Cuando la sentencia catch termina su ejecución el identificador deja de existir. Basicamente decimos intenta esto y si falla en algun momento o se genera algun error empieza a correr las instrucciones dichas en el catch. Sirve para manejar errores. El finally se ejecuta siempre, no importa si no hay catch. Sirve para ejecutar algo luego de q haga el try catch. Si el finally retorna un valor este valor se convierte en el retorno de toda la produccion del try / catch / finally, no importa los returns del try y del catch

* MANEJADOR DE EXCEPCIONES UNCAUCHT ---> para esto en nodeJs existe un event listener de process que se llama process.on('uncaughtException', funcion para manejar el error). Esto nos permite capturar los errores por fuera del trycatch y hacer algo antes de q el programa termine por un error

* BUCLES Y ITERACIONES --->
  - for ---> es un bucle que itera, se le pasan 3 parametros, el valor inicial, el final, y el sumador. Los 3 parametros son opcionales, si no se le pasa la condicion de la exprecion, osea el valor del medio. Por defecto le da true, si hacemos esto debemos asegurarnos de poner un break en el body del for para no crear un loop infinito. Incluso se puede llamar a la sentencia for sin una sección de sentencia. Esto se hace haciendo uso de la incrementExpression para dirigir la lógica deseada.
  - do...while ---> Se ejecuta una vez antes de que la condicion sea checkeada. Luego si la condicion es true se vuelve a ejecutar. Al final de cada ejecucion se vuelve a checkear la condicion para ver si la ejecuta de nuevo o no.
  - while ---> si la condicion se convierte en falsa el bloque de codigo dentro del while deja de ejecutarse y sigue con el codigo siguiente. Se checkea la condicion antes de ejecutar siquiera una vez el codigo de adentro, esa es la diferencia con el do...while
  - sentencia etiquetada ---> podemos etiquetar un bucle y luego usarlo en continues o break para manejar el flujo de nuestro bucle. Si etiquetamos algo q no sea un bucle solo podemos usar el break. El continue se usa solo con las etiquetas de bucle
  - si usamos break con una etiqueta de sentencia termina eso. Si la usamos sin una etiqueta termina el while, for, switch, do...while
  - el continue puede usarse para resetear una nueva iteracion del bucle. Si pones continue vuelve a hacer la comparacion en el bucle y si da true lo recorre de nuevo, ignora las instrucciones q tiene abajo del continue

* FOR ... IN ---> La declaración for...in itera una variable especificada sobre todas las propiedades enumerables de un objeto.

* FOR...OF ---> Si tratamos de usar esto sobre un objeto dara un error. Para objetos for in, esto es para elementos iterables como arrays o strings. Podemos acceder al indice del array haciendo el codigo del siguiente ejemplo:
  let colors = ['Red', 'Green', 'Blue'];
  for (const [index, color] of colors.entries()) {
    console.log(`${color} is at index ${index}`);
  }

* FUNCIONES ---> son un conjunto de ordenes que realizan una tarea o calculan un valor. Generalmente suelen necesitar un input y retornan un output. Para utilizar una función, debe definirla en algún lugar del ámbito desde el que deseas llamarla. Las funciones son objetos y tienen metodos, estos métodos nos son
útiles cuando se necesita manipular el alcance de la función. Los parametros son los que recibe la funcion y podemos manipularlos dentro del bloque de la funcion sin tener interferencia fuera de ella. Esto pasa con variables simples pero al pasarle objetos o arrays si podemos modificarlos y q quere asi, ya q lo que es inmanipulable es la referencia a memoria

* TIPOS DE VARIABLES
  - DECLARACION DE FUNCIONES ---> se definen con la palabra reservada function
  - FUNCIONES CON VARIABLES ---> se definen en una constante. Pueden ser nombradas o anonimas(flecha). Nombrarla es util para que pueda ser llamada a si misma y asi pueda iterarse

* DIFERENCIAS CON RESPECTO A LAS DECLARACIONES ---> las que son declaradas con la palabra function pueden ser llamadas antes de su declaracion. En cambio las que guardamos en una variable pueden ser indefinidas si las almacenamos en una variable VAR o pueden dar error si son de tipo LET o CONST y las llamamos antes de ser declaradas

* PILA DE FUNCIONES Y ALCANCE. RECURSIVIDAD ---> una funcion puede refereenciarse a si misma y llamarse. Existen 3 formas de llamarse:
  - NombreDeLaFuncion()
  - arguments.callee()
  - foo()

* ANIDACION DE FUNCIONES Y CLOUSURES(CIERRES) ---> cuando una funcion anida a otra funcion. La funcion interna es 'privada', osea q no pueden accederse desde fuera de la funcion. Esto es un clousure. Un clousure es una expresión (más comúnmente, una función) que puede tener variables libres junto con un entorno que une esas variables (que "cierra" la expresión). Un clousure es cuando una funcion utiliza una variable que esta fuera de su alcance. Una variable que esta por fuera de la funcion.
  - Clousure:
    * Solo se puede acceder a la función interna desde declaraciones en la función externa
    * La función interna forma un cierre: la función interna puede usar los argumentos y variables de la función externa, mientras que la función externa no puede usar los argumentos y variables de la función interna

* CLOUSURES ---> JavaScript permite el anidamiento de funciones y otorga a la función interna acceso completo a todos los variables y funciones definidas dentro de la función externa (y todas las demás variables y funciones que la función externa tiene acceso). Sin embargo, la función exterior no tiene acceso a la variables y funciones definidas dentro de la función interna. Esto proporciona una especie de encapsulación para las variables de la función interna. Además, dado que la función interna tiene acceso al alcance de la función externa, las variables y las funciones definidas en la función externa durarán más que la duración de la función externa ejecución, si la función interna logra sobrevivir más allá de la vida de la función externa. un cierre se crea cuando la función interna de alguna manera está disponible para cualquier ámbito fuera del exterior función

* ARGUMENTS OBJETOS ---> Los argumentos de una función se mantienen en un objeto similar a una matriz. Dentro de una función, puede abordar los argumentos que se le pasan como argumentos[i].

* FUNCIONES FLECHA ---> los 2 factores que influenciaron las funciones flechas son: que son mas cortas y q no tienen vinculaciones (no es necesario usar el this).

* CARACTERISTICAS ES6 (ECMASCRIPT 6) --->
  - Valores de parametros por defecto. Antes de ES6 se le debia pasar si o si por argumento un valor por defecto a la funcion para cada parametro. Desp de ES6 se le puede asignar valores por defecto en los parametros. Esto hace que al momento del llamar la funcion sean 'opcionales ?'. Por defecto se le puede asignar lo que sea. Desde datos comunes, hasta funciones o mismos parametros pasados en otros parametros. Tenemos que tener cuidado asignando parametros a otros parametros, ya q si asignamos uno que todavia no esta definido a otro, esto generara un error.

	- Rest Params ---> ejemplo: function multiply(multiplier, ...theArgs){ // codigo // }. Esto hace q el ...theArgs se le pasen todos los parametros restantes como un array. Sirve para tener una cantidad de parametros indefinidos. Este ...theArgs debe aparecer SIEMPRE al final de la lista de parametros, sino generara un error

	- Spread operator ---> Despliega los elementos de la variable en cuestion en un objeto iterable. ejemplo:
    const odd = [1,3,5];
    const combined = [2,4,6, ...odd];
    - utilidades del spread operator:
      - construir nuevos arrays --->
        const odd = [1,3,5];
        const combined = [2,...odd, 4,6];
      - pasar argumentos desde un array --->
        function compare(a, b) { return a - b }
        let result = compare(...[1, 2]);
      - concatenar arrays --->
        let numbers = [1, 2];
        let moreNumbers = [3, 4];
        let allNumbers = [...numbers, ...moreNumbers];
      - copiar arrays --->
        let scores = [80, 70, 90];
        let copiedScores = [...scores];
      ** OBS el spread operator solo copia los elementos. Por lo tanto es una copia superficial

	- mejora en nombramiento de objetos ---> permite en un objeto y la key y el value son el mismo no poner ejemplo: nombre: nombre. Basta con poenr nombre y lo entiende

	- para acceder a un elemento de un objeto ---> antes de ES6 se debia poner solo una variable o un string, ahora se puede poner una expresion q javascript evalua. Ejemplo user['nam' + 'e']

	- Hace que para declarar un metodo en un objeto ya no se necesiten los ':' ni la palabra function. Ejemplo:
    let objetoCreado = {
      name: 'nicolas',
      'reseteo'(){ console.log('reseteamos')}
    }
    objetoCreado['reseteo']

	- etiquetado de template strings ---> permite pasarle a una funcion un template string en el cual toma un array con los strings cortados por las variables utilizadas en el template (``). Ejemplo:

    let variable = infoPersona `bienvenido ${nombre} ${apellidos} aqui trabajaras de ${profesion} gracias por habernos elegido`;

    function infoPersona(strings ,nombre,apellidos, profesion) {
      return strings[0]+ nombre + strings[1] +apellidos + strings[2] + `${profesion}` + strings[3];
    }
    ** se puede pasar los parametros asi: function format(literals, ...substitutions) {}
		*** literals es un array con los strings y subtitutions es un array con los valores pasados en el template string

	- destructuracion de array ---> Se toman los valores en el orden que llegan. Si le pasaramos entre los corcheres a la desestructuracion mas elementos de los q retorna la funcion, los excedentes, osea los ultimos quedarian como undefined. Ademas podemos agregarle valores por defecto. Ademas es posible usar el spread operator. Ejemplo:
		function getScores() {
			return [70, 80, 90];
		}
		const [x, y ,z = 130] = getScores();

	- destructuracion de objetos ---> lo mismo con los arrays. Ademas podemos asignarle nombre. Ademas tambien podemos obtener solo los valores que queremos, no importa el orden. Ejemplo:
		let { firstName, lastName } = person;
		{ property1: variable1, property2: variable2 } = object;
		let { firstName: fname, lastName: lname } = person;

	- modulos ---> Un módulo ES6 es un archivo JavaScript que se ejecuta solo en modo estricto. Significa que cualquier variable o las funciones declaradas en el módulo no se agregarán automáticamente al alcance global.
		* exportando ---> Se puede exportar una variable, una función o una clase. Tenga en cuenta que la palabra clave de exportación requiere la función o clase para tener un nombre para ser exportado. No puede exportar una función o clase anónima usando esta sintaxis. Ejemplos:
			export let message = 'Hi';
			export function getMessage() {
				return message;
			}
			export function setMessage(msg) {
				message = msg;
			}
			export class Logger {
			}
		* importando ---> Especifique qué importar dentro de las llaves, que se denominan enlaces y el modulo del cual lo hara. Tenga en cuenta que cuando importa un enlace desde un módulo, el enlace se comporta como si estuviera definido usando const. Significa que no puede tener otro identificador con el mismo nombre o cambiar el valor de la Unión. Notar que al importar una funcion y una variable desde un modulo si ejecutamos esa funcion puede cambiar el valor de la variable importada dentro.
			- Ejemplo de import:
				import { what, ever } from './other_module.js';

			- Ejemplo de import con cambio de valores
				import {message, setMessage } from './greeting.js';
				console.log(message); // 'Hi'
				setMessage('Hello');
				console.log(message); // 'Hello'
				** note que si poneemos messate = 'otrostring' daria error pq no podemos cambiar la variable directamente, sino que estamos llamando una funcion. JavaScript detras de escena cuando llamamos a esa funcion va al otro modulo y la ejecuta y ahi es donde tiene acceso a la otra variable
		* importado de un modulo entero y renombrarlo ---> con el '*'. Ejemplo: import * as cal from './cal.js';
		* debes usar los import y export fuera de condicionales o funciones. El motivo del error es que JavaScript debe determinar estáticamente qué se exportará y importado.
		* alias ---> esato se hace con el 'as'. Ejemplo: export { add as sum }; Otro ejemplo: import {sum as total} from './math.js';
		* podemos importar un modulo q no tenga ningun export simplemente poniendo: import './archivoAImportar'; Y luego podemos usar sus funciones
		* para importar cosas por default y cosas q no son por default ---> debemos seguir estas reglas:
			- los import por default deben ir primero y sin {}. Luego deben ir los que no son por default y deben ir entre llaves.
			- Para renombrar un export por defecto debemos: import { default as quicksort, heapSort} from './sort.js';

* PROGRAMACION ORIENTADA A OBJETOS ---> Describimos el problema en terminos de objetos. Para esto utilizamos las clases. Las clases son un modelo para crear objetos. Estas encapsulan la data y funciones que manipulan esa data.
Las clases al igual que las funciones de expresiones (funciones asignadas a una variable) no pueden usarse antes de su inicializacion. Ademas es posible pasar una clase en una funcion o retornarla de la misma. La diferencia entre las clases y los custom types(antes de ES6) son las siguientes:
  - las clases no se inicializan como las funciones
  - todo el codigo dentro de la clase automaticamente se ejecuta en modo stricto y no podemos cambiar esto (como q estan encapsuladas ?)
  - los metodos en las clases no son enumerables
  - llamar al constructor de la clase sin el operador new antes dara un error

* SINGLETON ---> es un patron de diseño que se asegura de que solo pueda crearse una instancia de esa clase. Por ejemplo una clase que se conecte al servidor, esta no tiene sentido q haya dos instancias de la misma. Ejemplo en codigo:

  Class Singleton{
      static instance;
      nombre = '';

      constructor(nombre = ''){
          if(!!singleton.instance){
              return singleton.instance;
          }
          singleton.instance = this;
          this.nombre = nombre;
      }
  }

  const instancia1 = new Singleton('Nicolas');
  const instancia2 = new Singleton('Pedro');
  // En el ejemplo el if con !! ---> significa q si no es la primera vez, osea undefined te lo retorna y corta ahi. Sino les asigna nombre. la instancia2 no modifica le nombre, no sirve para nada

* METODOS ESTATICOS ---> Por definición, los métodos estáticos están vinculados a una clase, no a las instancias de esa clase. Por lo tanto, los métodos estáticos son útiles para definir métodos auxiliares o de utilidad. Ejemplo en codigo:
  class Person {
    constructor(name) {
      this.name = name;
    }
    getName() {
      return this.name;
    }
    static createAnonymous(gender) {
      let name = gender == "male" ? "John Doe" : "Jane Doe";
      return new Person(name);
    }
  }
  let anonymous = Person.createAnonymous("male");
  // si tratas de llamar al metodo createAnonymous desde una instancia de la persona te dara error, estos solo pueden ser llamados desde la clase (en este caso Person)

* HERENCIA ---> hereda las propiedades de otra clase como padre. Ejemplo codigo:
  class Animal {
    constructor(legs) {
      this.legs = legs;
    }
    walk() {
     console.log('walking on ' + this.legs + ' legs');
    }
  }
  class Bird extends Animal {
    constructor(legs) {
      super(legs);
    }
    fly() {
      console.log('flying');
    }
  }
  let bird = new Bird(2);
  bird.walk();
  bird.fly();
  ** con la llamada super() hace referencia al constructor del padre. Y con la palabra extends <clase padre> hace referencia a q extienda todas las propiedades q tiene esa clase a esta nueva (herencia). Javascript necesita q si la clase hija tiene un constructor llame a la clase padre mediante super(parametros para el constructor del padre)
  ** Podemos tener en la clase padre y en la hija metodos con el mismo nombre, pero al llamar cualquier cosa de la clase padre en alguna parte del hijo debemos usar super. <lo q vamos a traer>. Esto hace q podamos tener mismos nombres pero se puedan diferenciar una de otra con super. Ejemplo en codigo:
    class Dog extends Animal {
      constructor() {
        uper(4);
      }
      walk() {
        super.walk();
        console.log(`go walking`);
      }
    }

  * heredar statics ---> Además de las propiedades y métodos, la clase secundaria también hereda todas las propiedades y métodos estáticos de la clase padre.

* FUNCIONES FLECHAS ---> Son funciones que llevan '=>'. Y si se escriben en una linea ni siquiera deben llevar '{}' Ejemplo:
  let except = msg => {
    throw msg;
  };

* TYPESCRIPT ---> amplia las funcionalidades de javascript, estoy significa que cualquier codigo en javascript puede ser interpretado por typescript. La caracteristica principal que nos da typescript es el sistema de tipado. Hace q a cada variable le asignemos un tipo de dato. Convierte de un tipado debil y dinamico como es el de javascript en uno fuerte y estatico. En el inicio javascript nacio para resolver problemas pequeños en el navegador y no para proyectos grandes y escalables, es ahi donde typescript es una gran solucion. Javascript es un lenguaje interpretado, por lo tanto cada linea de codigo es evaluada y ejecutada en tiempo de ejecucion por el motor de javascript. Hace imposible tener un control de errores de tipo o algunos errores que tal vez no te das cuenta al no ser tipado. Esto hace q sea importante usar typescript en lenguajes grandes y escalables, para que no salgan errores a produccion

* LENGUAJES TIPADOS ESTATICOS VS DINAMICOS ---> los debilmente tipados son mas faciles de aprender, tambien son mas facil de trabajar con operaciones entre distintos tipos de datos. Pero por otra parte esto hace que este mas predispuesto a cometer errores. Y aun mas importante que al ser en runtime(tiempo de ejecucion) no podemos detectar estos errores al menos que corramos el programa o peor aun puede ya estar en produccion. En cambio los de tipado estatico y fuerte son mas verbosos (escribis mas) y requiren un codigo mas intrincado. Pero ofrecen un conjunto de ventajas que cobran importancia en grandes proyectos. Estos al ser compilado o transpilado(caso de typescript) muestran los errores pre-runtime(antes de la ejecucion del mismo). Esto hace q no se te pasen errores antes de sacarlo a produccion. Esto ayuda a la refactorizacion, mantenibilidad y escalabilidad del codigo.

* TYPESCRIPT INFIERE TIPOS ---> En la mayoria de casos los tipos de datos primitivos typescript los puede inferir, tal como lo hace javascript. Los tipos de datos primitivos q podemos usar son: boolean, bigint, number, string, null, undefined, symbol. Ademas de esto typescript agrega otros como: any(permite cualquier tipo), unknown(por ahora no se sabe, pero cuando se inicialice se sabra), never(no es posible que este tipo pueda suceder) y void(una funcion q retorne undefined o q no retorne nada). Existen dos formas de construir tipos en ts, con interface y con types. Debemos intentar usar interface casi siempre, al menos que usemos type para expecificar alguna caracteristica espeficia

* TIPOS VS INTERFACES ---> ambos pueden extenderse a otras interfaces y clases. Ejemplo en codigo. Es recomendable trabajar con interfaces en lo posible porque proporcionan mensajes de error mas especificos y utiles. Otras diferencia importante es que las interfaces son abiertas y los types cerrados. Esto quiere decir que una interfaz podemos extenderla o 'agrandarla' declarandola por segunda vez
  type Owl = { nocturnal: true } & BirdType;
  type Robin = { nocturnal: false } & BirdInterface;
  interface Peacock extends BirdType {
    colourful: true;
    flies: false;
  }
  interface Chicken extends BirdInterface {
    colourful: false;
    flies: false;
  }

* TIPOS COMPUESTOS ---> se declaran con un operador Or '|' . Es una union entre diferentes tipos o opciones. Ejemplo:
  const dias = 'lunes' | 'martes' | .... | 'domingo'
  // Otro ejemplo
  const dia: number | string = '12/12/2002'

* GENERICOS ---> proveen variables a los tipos. Ejemplo: type NumberArray = Array<number>;

* COMPONENTES DE TYPESCRIPT ---> son 3:
  1) Language −--> se compone de la sintaxis, las palabras clave y las anotaciones de tipo.
  2) compilador de typescriot ---> el (tsc) compila todo lo escrito en typescript a su equivalente en javascript
  3) El servicio de lenguaje TypeScript ---> ???????

* PROGRAMACION ORIENTADA A OBJETOS (POO) ---> La programación orientada a objetos consiste en modelar un sistema como una colección de objetos, donde cada objeto representa algún aspecto particular del sistema. Los objetos contienen funciones (o métodos) y datos. Un objeto proporciona una interfaz pública a otro código que quiere usarlo pero mantiene su propio estado interno privado; otras partes del sistema no tienen que preocuparse por lo que está pasando dentro del objeto

* POLIMORFISMO ---> permite a un metodo ser diferente, segun que clase(hija, q lo hereda) lo este usando.

* ENCAPSULAMIENTO ---> permite definir cuales de nuestros atributos y metodos van a ser privados. Define cual puede usarse desde fuera. Existen algunos metodos q manejan otros


---------------------------------------- REACT -----------------------------------
* JSX --->

* COMPONENTES ---> Los componentes permiten dividir la interfaz de usuario en piezas independientes y reutilizables, y pensar en cada pieza de forma aislada. Conceptualmente los componentes son funciones de javascript que aceptan propiedades heredadas del componente padre y que retorna elementos de react describiendo como deberian aparecer en la pantalla

* COMPONENTES FUNCIONALES Y COMPONENTES DE CLASE ---> los componentes funcionales son componentes que estan hechos como una funcion de javascript, en cambio, los de clase estan realizado mediante clases. En la actualidad los componentes de clases quedaron en desuso y se usan los funcionales

* COMPONENTES SIN ESTADO Y CON ESTADO ---> la diferencia es si mantienen un estado o no. Ambos componentes pueden recibir props

* PROPS ---> React es una biblioteca basada en componentes que divide la interfaz de usuario en pequeñas piezas reutilizables. En algunos casos estos componentes necesitan comunicarse y la forma de pasarse informacion entre ellos es a travez de las props. La palabra 'Props' es una palabra reservada de react. El pasaje de informacion es unidireccional. Solo se puede pasar del componente 'padre' al componente 'hijo'. Además, los datos de props son de sólo lectura, lo que significa que los datos procedentes del padre no deben ser modificados por los componentes hijos.

* STATE ---> El state es similar a los props, pero es privado y totalmente controlado por el componente. El state contiene datos específicos de este componente que pueden cambiar con el tiempo. El state es definido por el usuario, y debe ser un objeto JavaScript simple.

* CICLO DE VIDA --->
  ** ShouldComponentUpdate ---> Use shouldComponentUpdate() para que React sepa si la salida de un componente no se ve afectada por el cambio actual en el estado o props. El comportamiento predeterminado es volver a renderizar en cada cambio de estado, y en la gran mayoría de los casos, debe confiar en el comportamiento predeterminado. shouldComponentUpdate() se invoca antes de renderizar cuando se están creando nuevos accesorios o estados recibió. El valor predeterminado es true. Este método no se llama para el renderizado inicial o cuando forceUpdate() está usó.

  ** render ---> el metodo render es el unico requerido en los componentes de clase. Cuando se llama, examina los this.props y this.state y devuelve uno de los siguientes tipos:
    *** React elements ---> Normalmente se crea a través de JSX. Por ejemplo, <div /> y <MyComponent />
    *** arrays y fragments ---> permite devolver multiples elementos del renderizados
    *** portales ---> ???
    *** strings y numeros ---> estos son renderizados como nodos de texto en el DOM
    *** booleans y null ---> no renderizan nada
    *** la funcion render debe ser pura, lo q significa q no modifica el estado del componente y devuelve el mismo resultado cada vez q se invoca. No interactura directamente con el navegador

  ** ComponentDidMount ---> se invoca inmediatamente despues de montar un componente. Si se necesita hacer una request este es un buen lugar para realizarla

  ** ComponentDidUpdate ---> se invoca justo despues de que la actualizacion ocurra. este metodo no es llamado en el render inicial.

  * ComponentWillUnmount ---> se invoca inmediatamente antes de que el componente sea desmontado y destruido. Sirve para hacer una limpieza previa a la destruccion con sus estados, limpiar temporizadores, etc.

* COMPONENTES FUNCIONALES ---> no se pueden usar los ciclos de vida dentro del componente funcional. Pero podemos usar hooks, implementados en la version 16.8

* CONTROLADORES DE EVENTOS ---> en react es casi lo mismo q manipulando el dom. Excepto con algunas diferencias.
  ** los eventos en react se escriben en cammelCase
  ** con react pasamos una funcion como evento, en vez de un string. Ejemplo:
    For example, HTML:
    <button onclick="activateLasers()">
    Activate Lasers
    </button>
    React:
    <button onClick={activateLasers}>
    Activate Lasers
    </button>
  ** otra diferencia es que en react no podemos retornar false para prevenir el comportamiento por defecto. Tenemos que llamar a e.preventDefault() explicitamente para prevenirlo
  ** en react no necesitas llamar al addEventListener para agregar manipulacion de dom. Solo basta con pasarle al la etiqueta el evento y lo escuchara cada vez q ocurra automaticamente.

* RENDERIZADO CONDICIONAL ---> en react podemos encapsular algunos elementos del dom para usarlos o mostrarlos solo cuando nosotros necesitemos. Para eso condicionamos el return con un state. Se pone un if y un useState q varie entonces si pasa una cosa o la otra renderiza solo lo q este dentro de ese if

* LISTAS Y KEYS ---> las keys deben ser unicas y deben proporcionarse adentro de un mapeo de elementos html. Esto ayuda a react a identificar cada elemento para saber si esta cambiando, siendo agregado o removido. Le da estabilidad. Si no tenemos elementos unicos dentro del array como para representar cada elemento del html podemos usar el index como segundo parametro y pasarselo. Ya que se ira incrementando en uno cada vez q renderice un elemento. No es recomendable usar index para pasar keys si los componentes pueden variar de lugar. Esto puede afectar negativamente el rendimiento y causar problemas en el componente

* FORMULARIOS ---> a veces en el submit de un form necesitamos controlar la data y pasarle una funcion para ver q decision tomamos en base a la informacion ingresada. Aca aparecen los componentes controlados.

  ** CONTROLLED COMPONENTS ---> en html comun las etiquetas como input, textarea o select tienen su propio estado y se actualizan en funcion de que ingrese el usuario. En cambio en react el valor se suele tomar en states y se pueden cambiar solo con el setState(). Podemos combinar el state y el setState para tener una "fuente de verdad". Esto hace que la reaccion del componente al ingresar informacion tambien controle lo que sucede en el formulario. A esto en react se le llama componente controlado. Osea, React le quita el control de estado a la implementación nativa del navegador y expone dicho control a ti, el desarrollador por medio de algunas simples API. Con esto logramos que pese a escribir un poco mas de codigo ahora podemos pasar los valores a otros elementos del dom o javascript

  ** COMPONENTES NO CONTROLADOS ---> a veces puede ser tedioso trabajar con componentes controlados ya que se necesita escribir un manejador de eventos para cada vez que los datos cambien. Entonces usando componente no controlados los datos del formulario son manejados por el DOM. Para hacer una implementacion esta manera es las mas rapida y con menos codigo. Pero deberia hacerse con componentes controlados

* FRAGMENTS ---> un patron comun en react es que un componente retorne varios elementos html. Los fragmentos que son como etiquetas vacias nos permiten devolverlas sin necesidad de poner una etiqueta o nodo padre en el dom. Ademas en caso de q se retornen 2 o mas elementos html como las etiquetas mas grandes del componente las usamos para que no de error, ya q el return solo permite tener una etiqueta html q englobe las etiquetas hijos

* HIGH ORDER COMPONENTS ---> son funciones que permiten recibir componentes y retornan otros componentes. Usamos un componente de funcion flecha y se recomienta arrancar con la palabra with y seguida de lo que va a ser. Podemos encerrar a otros componentes con estos por ejemplo en el export default

* React provee una api para que el renderizado de los elementos haga su magia por detras y se nos haga mas facil desarrollar una aplicacion. El metodo render() crea arboles en donde cada componente tiene sus hijos q son arboles anidados. Al diferenciar dos arboles react primero compara los elementos 'root' (raiz). El comportamiento es diferente dependiendo de los tipos de elemento raiz

* ALGORITMO DE DIFERENCIACION --->
  ** elementos de diferentes tipos --->
  ** elementos de mismo tipo

* VIRTUAL DOM ---> El DOM virtual (VDOM) es un concepto de programación en el que una representación ideal o "virtual" de una interfaz de usuario se mantiene en la memoria y se sincroniza con el DOM "real" mediante una biblioteca como ReactDOM. Este proceso se llama reconciliación.

* REACT HOOKS ---> fueron agregados en la version 16.8 de react. Son funciones que permiten 'engancharse' de los estados y las caracteristicas y momentos del ciclo de vida de los componentes funcionales. Los hooks no funcionan dentro de componentes de clases. Reglas para los hooks:
  ** solo llame hooks en el nivel superior del componente. No declare hooks dentro de funciones anidadas, condicionales o bucles
  ** solo puede llamar hooks desde componentes funcionales, no desde funciones regulares de javascript. El otro lugar valido para llamar hooks son los custom hooks. Son los que creamos los desarrolladores para nuestras utilidades, generalmente empiezan con use cuando los declaramos.

* USESTATE ---> sirve para agregarle algun estado local al componente que necesitamos. React conserva este estado entre las renderizaciones. Este hook devuelve un par: valor actual del estado y funcion para modificarlo. El unico argumento q le pasamos al useState es su valor inicial.

* USEEFFECT ---> Las peticiones de data (fecheo de data), subscripciones o cambios manuales del dom. Son algunas de las acciones que no pueden realizarse mientras se renderiza un componente ya que podria afectarlo. Aca es donde entra en juego useEffect, que espera a q se rendericen todos los elementos y luego ejecuta las acciones que tiene dentro. Este hook tiene 2 parametros. El primero es una funcion flecha que tiene las intrucciones que queremos ejecutar luego del renderizado y si ademas le ponemos un return y algunas acciones, esas acciones se ejecutaran solo cuando el componente sea desmontado o removido. Y el segundo parametro es un array con los states que tiene q capturar si cambian para volver a lanzar las ordenes q tiene la funcion flecha. Por defecto ese hook se corre siempre, incluido desp de terminar el primer renderizado.

* USECALLBACK ---> Un callback es una funcion que se pasa como argumento a otra funcion. Este hook memoriza el callback por lo tanto no vuelve a crear la funcion cada vez q renderiza. Cada vez q se modifica algo del dom, se vuelven a crear todas las constantes y funciones que estan en el cuerpo del componente(excepto los hooks). Entonces ahi entra este hook para memorizar un callback(funcion) para q no se vuelva a crear. Mejora le rendimiento. Usarlo cuando son funciones grandes q sabes q no van a cambiar. Ademas hay q tener cuidado pq al primer uso del a funcion la variables quedan seteadas y no cambian, para esto podemos usar setState(preState => preState + lo que queramos hacer). A este hook igual q el useEffect se le pasan 2 parametros, una funcion flecha con las cosas q queres q no cambien y el segundo un array con las dependencias, estas dependencias son las q si cambia la funcion cambia. De no varias estas dependencias memoriza la funcion y la renderiza 1 sola vez

* USEMEMO ---> memoriza un valor y solo si una dependencia que le paso cambia volvemos a calcular el valor. Sirve para hacer una mejor performance, ya q hay operaciones que pueden ser pesadas y no es recomendado que se vuelvan a renderizar en cada renderizado. La funcion pasada al useMemo es ejecutada en el renderizado, no como el useEffect q espera a q termine el renderizado.

LLEGUE A REACT ROUTER DOM PAGINA 15



PREGUNTAR:
que significa foo()
array literales y git diff.
que es la referencia a memoria y porque es inmutable pero lo de adentro de un objeto o de un array no lo es
clousure
Getter and Setter (pagina 46)
3er componente de typescript al final de la pagina 60
* en typescript se define una clase asi ?
class Student : extends Person
  properties
   private year
  constructor
    Student(name, year)
  methods
  introduceSelf()
  canStudyArchery() { return this.year > 1 }
  student = new Student('Weber', 1)
  student.year // error: 'year' is a private property of Student

PREGUNTAS REACT --->
JSX
COMPONENTES CON Y SIN ESTADO ---> la diferencia es si tienen renderizado condicional o si tienen useStates adentro ? pagina 3
que son los portals ??? pagina 5
high order component
Reconciliation pagina 10