------------------------------- Redux form ----------------------------
* Wrapeamos nuestro input dentro de un componente de redux form llamado Field
* Para usar ese componente wrapeamos el componente en el q usamos la data con reduxForm
ejemplo:

import {reduxForm} from 'redux-form';
export default reduxForm({ form: 'NombreDelForm'})(Home);

* Luego a la etiqueta Field le pasamos props, ejemplo
<Field name='NombreComoSeGuardaEnRedux' component={componente q creamos con el input} />

* Luego cuando tenemos el boton de submit le pasamos la propiedad q nos da redux-form.
* handleSubmit(1 parametro). Este parametro q le pasamos es una funcion q recibe y la cual va a recibir los valores del formulario implementado por redux. ejemplo

<form onSubmit={handleSubmit(FuncionX)}> field1, field2, ... </form>

* FuncionX es la funcion que recibe los values directamente al hacer submit
* existe una prop q destruye los valores cuando este componente se desmonta
* Tambien se le puede pasar otras propiedad con las validaciones al form. Ejemplo

import {reduxForm} from 'redux-form';
export default reduxForm({
  form: 'NombreDelForm',
  validate: funcionQvalida,
  warn: funcionQvalidaYDaWarnings,
})(Home);

* Para obtener los valores del input que quieras existe formValueSelector. Esto debe usarse medidamente, ya que re-renderiza todo de nuevo.
* Para usarlo, debemos:
1) import { formValueSelector } from 'redux-form'
2) const selector = formValueSelector('NombreDelForm')
Esto creará una función que obtendrá cualquier valor de ese formulario del estado global de Redux
3) const value = selector(state, 'NombreDelInputQuePasamosAlField')

* Para hacer un formulario con redux
1) import { reduxForm } from 'redux-form'
 reduxForm(
  form,
  asyncBlurFields,
  asyncChangeFields,
  asyncValidate,
  destroyOnUnmount,
  enableReinitialize,
  forceUnregisterOnUnmount,
  getFormState,
  initialValues,
  onChange,
  onSubmit,
  onSubmitFail,
  onSubmitSuccess,
  validate,
  warn,
 )

form ---> 'nombre del formulario que vas a usar de redux'. Es el unico required

asyncBlurFields ---> Array de strings, opcional. validacion asinscronicas q se hacen en el onBlur de los inputs

asyncChangeFields  ---> Array de strings, opcional. nombres de campo en los cuales el onChange debería activar una llamada a la función asyncValidate.

asyncValidate ---> una función que toma todos los values del form, los dispatch, las props del componente y el onBlur actual. Devuelve una Promesa que resolverá si se pasa la validación, o rechazará con un objeto de errores de validación en el formulario con el siguiente formato:
{ campo1: <Cadena>, campo2: <Cadena> }
Sintaxis de asyncValidate
asyncValidate : (values:Object, dispatch:Function, props:Object, blurredField:String) => Promise<undefined, errors:Object> [optional]

destroyOnUnmount ---> Es un booleano, opcional. Le decis si queres que destruya el state del formulario una vez se desmonta el componente, El valor por default es true

enableReinitialize ---> Es un booleano, opcional. Cuando se establece en verdadero, el formulario se reinicializará cada vez que cambie la propiedad initialValues. El valor predeterminado es falso. Si también se establece la opción keepDirtyOnReinitialize, el formulario conservará el valor de los campos sin validar cuando se reinicie.

forceUnregisterOnUnmount  ---> Es un booleano, opcional. Ya sea para forzar o no la anulación del registro de los campos: utilícelo junto con destroyOnUnmount. Útil para formularios de tipo asistente en los que desea destruir campos a medida que se desmontan, pero no el estado del formulario. El valor predeterminado es falso, ya que los formularios normalmente se destruyen al desmontarlos.

getFormState ---> Funcion, opcional. Una función que toma todo el estado de Redux y devuelve el segmento de estado que corresponde a donde se montó el reductor de forma redux

initialValues ---> Objeto, opcional. Recibe clave y valor de cada campo con sus valores iniciales

onChange ---> Funcion, opcional. Un callback q se llamara cada vez que los valores de los inputs cambien

onSubmit ----> Funcion, opcional. Es la función que tiene los values del formulario cuando handleSubmit() se activa desde dentro del componente del formulario. Si no lo especifica como prop, debe pasarlo como parámetro a handleSubmit() dentro de su componente de formulario.

onSubmitFail ---> Funcion, opcional. Funcion que se llama cuando el submit falle.

onSubmitSuccess ---> Funcion, opcional. Un callback q se ejecuta cuando el submit es exitoso.

validate ---> Funcion, opcional. Es una funcion sincronica de validacion. Que toma los values y las props, en ese orden. Si la validacion pasa te devuelve un {} vacio, sino te da un objeto con los errores

warn ---> Funcion opcional. Funciona igual q validate pero con warnings en vez de errores.

** metodos q podemos acceder en el componente q conectamos con reduxForm.

dirty ---> devuelve true cuando los valores del formulario actual son diferentes de los valores iniciales, devuelve false en caso contrario.

fieldList ---> Un array de strings, con los nombres de los inputs

invalid ---> true cuando el formulario no es válido (tiene errores de validación), false en caso contrario.

valid ---> la contraria a invalid.

pristine ---> true when the current form values are the same as the initialValues, false otherwise.

reset() ---> Restablece el formulario a los valores iniciales.

resetSection() ---> resetea solo los seleccionados.

submit() ---> Cuando hacemos submit en el form. Devuelve una promesa q segun como se resuelva el submit te da reject o resolve.

values ---> Los values actuales de los inputs

* formValues() ---> selecciona los values de todos los inputs (creeeo)
import { formValues } from 'redux-form'

const allValues = formValues('nombreDelForm')(MyItemizedList)
VER

--------------------------------------- Provider -----------------------------
* es la etiqueta q importamos de la libreria 'react-redux' y nos provee un store para obtener info

import {Provider} from 'react-redux';

return(
  <Provider store={NuestroStoreQueDebemosImportar}>
    .... Todos los componentes q van a tener la info del store
  </Provider>
)

--------------------------------------- useDispatch ---------------------------------------
* se importa de la libreria 'react-redux'. Sirve para despachar acciones o thunks q tengamos . La constante dispatch luego es una funcion q le pasamos la accion q vamos a ejecturar. Ejemplo

const dispatch = useDispatch()
--------------------------------------- useSelector ---------------------------------------
* nos devuelve la porcion del state que queremos.
* Los selectores sirven para derivar data , mapear o filtrar lo q recibimos

const pokemones = useSelector(state => state.pokemones)

--------------------------------------- CombineReducers ---------------------------------------
* sirve para combinar nuestros reducers y luego tener uno solo q exportaremos y usaremos para encerrar toda nuestra app con el store. El metodo CombineReducers acepta un objeto con los nombres y como clave los reducers. Al final pasamos ese reducer root como el q vamos a usar

import {CombineReducers}

const rootReducer = CombineReducers({});
const store = createStore(rootReducer);





**************************************** DOCUMENTACION ****************************************

* Redux es un patrón y una biblioteca para administrar y actualizar el estado de la aplicación, utilizando eventos llamados "acciones". Sirve como un almacén centralizado para el estado que debe usarse en toda su aplicación, con reglas que garantizan que el estado solo se puede actualizar de manera predecible.

* un solo flujo de datos ---> vista ---> accion ---> state ---> vista. Por ejemplo si la vista se apreta un boton, se despacha una accion q indica como debe variar el state. El state varia y se lo manda a la vista q toma los nuevos valores y renderiza de nuevo

* ACTION ---> una accion es un simple objeto de javascript q contiene un campo llamado type en el que debemos darle un nombre representativo de la accion q vamos a realizar. Ademas podemos pasarle informacion o variables, esto lo hacemos por convencion a travez de otro campo llamado payload q recibe toda esta informacion para pasarla al reducer. Ejemplo:

  const addTodoAction = {
    type: 'todos/todoAdded',
    payload: 'Buy milk'
  }

* existen los creadores de acciones que son funciones que retornan una accion. Esto es lo q se usa. Ejemplo

const addTodo = (data) => {
  return {
    type: 'todos/todoAdded',
    payload: data
  }
}

* REDUCER ---> Un reducer es una funcion que recibe el estado actual de la aplicacion y un objeto con la accion. Realiza la logica necesaria para actualizar el state. Solo deben calcular el nuevo valor de estado en función de los argumentos de estado y acción. No se les permite modificar el estado existente. En su lugar, deben realizar actualizaciones inmutables, copiando el estado existente y realizando cambios en los valores copiados. No deben hacer ninguna lógica asíncrona, calcular valores aleatorios o causar otros "efectos secundarios".

* STORE ----> El store es un objeto que contiene toda la infomacion global de la aplicacion q fuimos almacenando a traves de los reducers. Tiene un metodo llamado store.getState() que nos devuelve toda esa info

* DISPATCH ---> La unica forma de actualizar el state en redux es a travez de un dispatch q despache alguna action o thunk para q ejecute los reducers correspondientes y modifiquen el state.

* SELECTORES ---> son funciones que sirven para traer cierta parte de la informacion o mapearla para conseguir algo unico. En resumen, podes derivar data o modificarla para conseguir lo q necesites del state.

* razones por las que el state es inmutable:
Provoca errores, como que la interfaz de usuario no se actualice correctamente para mostrar los valores más recientes.
Hace que sea más difícil entender por qué y cómo se ha actualizado el estado.
Hace que sea más difícil escribir test.
Rompe la capacidad de usar la "depuración de viajes en el tiempo" correctamente
Va en contra del espíritu previsto y los patrones de uso de Redux.

* THUNKS FUNCTIONS ---> Son funciones que despachan acciones asincronicas. Por eso maneja los 3 estados de una peticion asincronica. Fetching, fulfilled y error. Y dentro de la funcion thunks despachada se despachan 3 acciones mas segun el estado de la peticion. Estas son las que modifican al reducer y al store segun en el momento q se encuentre

* PRINCIPIOS DE REDUX
1) tener una aplicacion predecible
2) centralizada ----> store global
3) debuggeable
4) flexible




****************************** DOCUMENTACION REDUX TOOLKIT QUERY ******************************

* createSlice ----> es una funcion que recibe como parametro un objeto. Este objeto debe tener un name, un initialState y un objeto con los reducers
* redux toolkit nos permite q en los reducers podamos mutar el state (state.counter = 10 por ejemplo) y ellos con una libreria q tienen llamada Immer por detras lo convierten a codigo inmutable
* configureStore ---> seria como el combineReducers
* cada createSlice exporta las acciones. Esto recibe directamente el payload y el nombre
* EJEMPLO:

import { createSlice } from '@reduxjs/toolkit'
import type { PayloadAction } from '@reduxjs/toolkit'

export interface CounterState {
  value: number
}

const initialState: CounterState = {
  value: 0,
}

export const counterSlice = createSlice({
  name: 'counter',
  initialState,
  reducers: {
    increment: (state) => {
      // Redux Toolkit allows us to write "mutating" logic in reducers. It
      // doesn't actually mutate the state because it uses the Immer library,
      // which detects changes to a "draft state" and produces a brand new
      // immutable state based off those changes
      state.value += 1
    },
    decrement: (state) => {
      state.value -= 1
    },
    // el payload es recibido directamente en el parametro de la action
    incrementByAmount: (state, action) => {
      state.value += action.payload
    },
  },
})

// Action creators are generated for each case reducer function
export const { increment, decrement, incrementByAmount } = counterSlice.actions

* una vez q tenemos el slice creado lo usamos en el index de redux (en el store). Ejemplo

import { configureStore } from '@reduxjs/toolkit'
import counterReducer from '../features/counter/counterSlice'

export const store = configureStore({
  reducer: {
    counter: counterReducer.reducer,
  },
})

// Infer the `RootState` and `AppDispatch` types from the store itself
export type RootState = ReturnType<typeof store.getState>
// Inferred type: {posts: PostsState, comments: CommentsState, users: UsersState}
export type AppDispatch = typeof store.dispatch





DUDAS ::::::
para que se usa createSlice
ver createAsyncThunk y createSlice, que es rkt query
ver tambien useSWR

de rkt query ver ---> createApi(), fetchBaseQuery()

HASTA ACA LLEGUE:::::
https://redux.js.org/tutorials/essentials/part-7-rtk-query-basics

SEGUIR DE ACA :::::::
CAPITULO 7
https://www.youtube.com/watch?v=6ISuVZVGa_o&list=PLCKuOXG0bPi3AWYFJewb-UhN7Y2VjooJL&index=6&ab_channel=FernandoHerrera


**************************************** tipado ********************************************************

* para el tipado en typescript ---> Redux toolkit (RTK) ya tiene el tipado pq esta hecho con typescript. React-redux no lo tiene. tenemos q importar @types/react-redux


* cuando configuramos redux con los reducers no necesitariamos nada mas. Pero podemos extraer el rootState y el dispatch como types. Ejemplo
  import { configureStore } from '@reduxjs/toolkit'

  export const store = configureStore({
    reducer: {
      posts: postsReducer,
      comments: commentsReducer,
      users: usersReducer
    }
  })

  // Infer the `RootState` and `AppDispatch` types from the store itself
  export type RootState = ReturnType<typeof store.getState>
  // Inferred type: {posts: PostsState, comments: CommentsState, users: UsersState}
  export type AppDispatch = typeof store.dispatch

**************************************** 3 principios de redux ****************************************

1) unica fuente de verdad ---> el estado de la aplicacion es global y es el unico donde puede consultarse o cambiarse
2) State is read-only ----> el estado es de solo lectura por eso siempres se devuelve una copia del state en lugar del mismo state
3) los cambios se hacen con funciones puras ---> para esto debemos tener reducers "puros". Los reductores son solo funciones puras que toman el estado anterior y una acción, y regresan al siguiente estado. Recuerde devolver nuevos objetos de estado, en lugar de mutar el estado anterior.




empezar de aca
https://redux.js.org/tutorials/essentials/part-1-overview-concepts






