* las propiedades en el documento cuando hacemos un findOne por ejemplo, estan en _doc ---> ahi estan las props comunes del objeto js
* A veces no hace el .save pq le faltan las propiedades de mongo al documento que busque. Generalmente es porque hice un .lean()
* para borrar props de un documento usar $unset
* funcion que mapea promesas
    const getClientList = async (ids = [], mod) =>
      await Promise.all((ids)
        .map(async (id: any) => await mod.findOne({
          _id: id, isActive: true, logicDelete: false
        })));
* CX la libreria de clases le mandas entre llaves  todas las clases que queres aplicar a ese elemento, si se la pasas comun como en un objeto se la aplica siempre, pero si en cambio se la pasas con el formato ---> [css.propiedad]: variableBooleana. Esto hace que si la variable es true aplica la clase y si es false no aplica la clase
* para tipar las funciones que pasamos como parametros es asi: (los params de la funcion tipados) => tipado de lo que retorna, si no retorna nada se le pone void
* las clases q veo en el html del navegador son asi: nombreDelComponente_nombreClase_hashAleatorio, eso lo genera react
* cuando compato strings o cosas falsy, ponerle antes el !! pq a veces react renderiza un cero si es false.
* Para crear un archivo desde la terminal es por ejemplo asi: cat > nombreArchivo.txt
* Para eliminar una carpeta desde la terminal, nos paramos en la carpeta padre y ponemos rm -rf nombreCarpeta
* A Los schemas de mongodb se le pueden agregar metodos. Por ejemplo si tenemos un schema user podemos hacer un metodo que encripte la contraseÃ±a, entonces luego al crear un new User podemos aplicarle el metodo creado en el schema.
* En el caso de que en un schema tengamos una prop que se puede popular en varias collections distintas. Lo mejor que podemos hacer es pasarle a ese id la prop 'refPath': Otra prop del schema con el nombre de la collection a la que debe popular. Entonces cuando hagamos el populate de la prop ya sabe a que collection ir a buscar
* Para podes usar el _doc de un modelo tenemos que tipar el schema y extenderlo de Document.
* En javascript, las promesas siempre retornan promesas, asi funciona el metodo, esto es asi para poder concatenar todos los .then() que querramos
* En mongoose tenemos el metodo sort que te ordena ascendente o descendentemente por la propiedad que querramos
* en un onchange o onclick, el evento podes obtener el codigo de la letra. e.keyCode ---> con esto podemos saber que tecla apreto y condicionar el evento
* El virtuals de mongoose es una propiedad que seteas en el schema pero que no la vas a guardar en la base de datos. Es util para usarlo con propiedades claculables como la edad, etc.
* en los headers de una request se mandan cosas relacionadas a el formato de la data o informacion sobre la request, en cambio en el body mandamos informacion que queremos transportar.
* para tener algo relativo a un componente padre en css, a la etiqueta padre le asignamos una clase con position relative y a la q vamos a mover con absolute. Entonces esa clase q vamos a mover es absoluta al padre, en vez de a toda la pantalla
* en css tenemos la prop ellipsis que nos da los ... en el texto
* Si trabajo con .save(), muto directamente las propiedades del documento.
* Si trabajo con findByIdAndUpdate y lean o aggregaet --> spread operator y mando todo el objeto
* Si tengo un middleware de validacion puedo pasar la lo que quiera a la siguiente funcion con req.customNombre = variableAPasar. Despues ponemos next() y deberiamos podes acceder en la siguiente funcion mediante req.customNombre
* Para linkear bien y pushear un repo a github tenemos q generar la key en developer settings, ya que no acepta mas la password de la cuenta. Aca podemos ver como se hace ---> https://stackoverflow.com/questions/68775869/message-support-for-password-authentication-was-removed-please-use-a-personal
* le pasas un archivo js y te crea los types de typescript ---> app.quicktype.io
* para tipar el set del useState ---> React.Dispatch<React.SetStateAction<tipo del state>>
* Si comiteaste y pusheaste en una branch que no es: 
1) Desde la branch local que hiciste el commit mal: git reset --soft HEAD~1
2) git stash -u
3) git checkout ramaQueQueres
4) git stash apply
5) Volves a hacer el commit
6) Pusheas desde la rama que queres
