R--------------------------------------- useContext ---------------------------------------
1) asignamos a una variable el createContext y la exportamos para usarla donde querramos
export const userContext = React.createContext();
2) Agarramos ese userContext como un componente y encerramos toda nuestra app con el componente.Provider. Ademas le damos un value con el store q vamos a tener para almacenar datos q pueda leer cualquier coponente dentro. Esta logica del context es ideal sacarla a un archivo aparte con funciones para manejar esa informacion etc.
return (
  <userContext.Provider value={storeConDatosQVamosAProveer}>
    <div></div>
    <img />
  </userContext.Provider>
)
3) En los componentes donde queremos leer esa data hacemos useContext
const dataDelContext = useContext(NombreDelContextoQVamosALeer)

--------------------------------------- useRef ---------------------------------------
* Use ref crea un objeto. En el cual tiene una key q se llama current q tiene el valor actual. Sirve para mantener un valor al menos que le indiquemos q lo cambie
* Seria como una variable que no se va a perder entre cambios de estados. Osea es una variable q se modifica pero no cambia en el render de la aplicacion, no va a volver a renderizarla.
* Si nosotros cambiamos ese valor nuestra aplicacion NO SE VUELVE A RENDERIZAR.
* Tambien podemos referenciar elementos del dom. En el elemento html ponemos la prop ref={variable q le ponemoss useRef()}

1) definimos el useRef
const name = useRef('valorPorDefecto')
2) luego en los lugares que queremos le modificamos el valor. Al ser un objeto, debemos acceder al a propiedad current
name.current = 'Cambio el nombre';

--------------------------------------- useMemo ---------------------------------------
* memorizamos un valor y solo si una dependencia q le pasamos en el segundo parametro cambia volvemos a memorizar el nuevo valor
* Sirve para no hacer renders innecesarios. Ejemplo

const prueba = useMemo(() => {}, [])
el primer parametro se hace la logica q usamos para calcular, el array q esta en el 2do parametro del useMemo es un array de dependencias. Son los elementos q si cambian se vuelve a ejecutar la funcion del primer parametro

--------------------------------------- useCallback ---------------------------------------
* memorizamos una funcion para q no se vuelvan a generar y a ejecutar en cada render, solo cuando cambien las dependencias q le pasamos en el array que esta en el segundo parametro del hook.
* La diferencia con useMemo es q el useCallback te devuelve la funcion memorizada, en cambio el useMemo te devuelve el valor calculado de la funcion. El callback, al devolvernos la funcion, podemos ejecutarla. Ejemplo

const ejemplo = useCallback(() => {}, [])

--------------------------------------- useReducer ---------------------------------------
* seria lo mismo q un useState pero si tiene muchas variantes para cambiar es preferible un useReducer. Serian para estados mas complejos. Tiene un state un dispatch q despacha las acciones y del otro lado le pasamos, el reducer y el inicial state. Ejemplo
import {useReducer} from 'react';

const initialState = {
  contador = 10
}

interface actionType { type: 'incrementar' | 'decrementar'}

const contadorReducer = (state: typeof initialState, action: actionType) => {
  switch( action.type) {
    case 'incrementar':
      return {
        ...state,
        contador: state.contador + 1
      }
    case 'decrementar':
      return {
        ...state,
        contador: state.contador - 1
      }
    default:
      return state;
  }
}

** luego en el componente o mas abajo definimos el reducer
** el init sirve por si tarda en cargar la data q trae q muestre algo
** y luego usamos el dispatch y le mandamos las acciones
** el action es un objeto q mandas el nombre de la action y el payload con la data q podes usar
** ademas en contadorState podemos desestructurar y traernos { contador }

const [contadorState, dispatch] = useReducer(contadorReducer, initialState, init)

() => dispatch({type: 'incrementar'})


--------------------------------------- useParams ---------------------------------------
* se importa de la libreria react-router. Sirve para extraer los parametros de la url. En el siguiente ejemplo en la constante params tenemos un objeto con cada param de la url con su nombre y valor. Ejemplo

const params = useParams()

--------------------------------------- useLocation ---------------------------------------
* se importa de la libreria react-router. la constante del ejemplo es un objeto con propiedades especificas.

const location = useLocation()

* Pathname, que seria luego de wwww.nombrepag.com lo q le sigue en la ruta de la url.
* Search son los query params q le pasamos a la url

Ejemplo para obtener las querys de forma facil.
const {search} = useLocation();
const query = new URLSearchParams(search);

// obtiene la query del precio q pasariamos
const price = query.get('price');

--------------------------------------- useHistory ---------------------------------------
* se importa de la libreria react-router. Te devuelve un objeto con varias propiedades. Este hook tiene tambien dentro el useLocation
* push, es una funcion q le pasas un string de parametro con el path al cual queres ir y te envia ahi
* goFoward, para ir adelante en el historial
* goBack, para ir atras en el historial
* go, para que vaya a alguna pagina
const history = useHistory()

--------------------------------------- useNavigate ---------------------------------------
* se importa de la libreria react-router. Es una funcion q le pasas el path y te navea a esa ruta.

const navigate = useNavigate()
navigate('/home')

--------------------------------------- react router dom -----------------------------------
* Link ----> es un componente q tiene esta libreria, es como una etiqueta <a> pero q tiene toda la logica que necesitamos. Para el href se reemplaza con un to={A donde nos redirije}. No puede usarse por fuera de una etiqueta Route
* BrowserRouter ---> tiene toda la api del history. Debemos encerrar las etiquetas link dentro de un BrowserRouter
* Route ---> Es un componente q le pasas path='Path al que vas a ir' y wrapeas el componente q vas a renderizar. Debemos pasarle el exact para q la ruta sea exacta en el path y renderice lo q queremos.
* Switch ---> hace q solo se quede con el primero q coincida. Con esta etiqueta wrapeamos las etiquetas Route

Ejemplo:

<BrowserRouter>
  <Link to='/contacto'>Contacto</Link>
  <Switch>
    <Route path='/contacto>
      <ContactPage />
    </Route>
  </Switch>
</BrowserRouter>

--------------------------------------- HOC ---------------------------------------
* los high order component son las funciones que tienen la capacidad de recibir un componente como parametro y retornar un componente nuevo
* se recomienda q al hacer estas funciones inicien con la palabra with y seguida de algo q represente
* recibe un componente hace logica y retorna el mismo componente mejorado con la logica o otro. Ejemplo
* son como los customHooks pero de antes

const withConsoleLog = (Component, config?) => {
  const WrappedComponent = () => {
    // ACA HACEMOS LA LOGICA
    return <Component />
  }

  return <WrappedComponent />
}

** despues wrapeamos nusetro componente con este HOC. Ejemplo
export default withConsoleLog(App);

--------------------------------------- Promesas ---------------------------------------
* un callback es una funcion que pasas por parametro para q la ejecute cuando termine la funcion y eso sea lo que retorna
* el constructor new Promises recibe una funcion con dos parametros q son resolve y reject
* entonces en una funcion nos quedaria

const funcWithPromises = (a, b ) => {
  const resultado = a + b;
  return new Promises((resolve, reject) => {
    //hago cosas y retorno lo q quiero
    resolve(funcionQueLePasoCuandoTerminaBien)
    reject(funcionQueLePasoCuandoTerminaMal)
  })
}

** el .then lo ejecuta  con el resolve y el .catch lo ejecuta con el reject
funcWithPromises(1, 3)
  .then((res) => console.log(res))
  .catch((res) => console.log('Errorrrrr'))


--------------------------------------- Promise All ---------------------------------------
* Promise.all ---> es un array de promesas q se hacen en simultaneo entonces acortan el tiempo de espera. Si falla una, va al catch directo
* Promise.allSettled devuelve un array en los q vas a poder saber si una de las promesas fallo o no. Siempre resuelve

Promise.all([
  ...array con las promesas
]).then((response) => console.log(response))
.catch(() => console.log('errrror'))

Promise.allSettled([
  ...array con las promesas
]).then((values) => console.log('aca tenemos un array con cada promesa y errores o estado', values))
.catch(() => console.log('errrror'))

--------------------------------------- React Query ---------------------------------------
* sirve para las peticiones
* necesita un provider
* podemos importar ReactQueryDevtools q sirve para debuggear las request

const { data, status } = useQuery('ClaveQueRepresenteLoQueLePasamos', FuncionQueSeEjecutaCuandoQueremosLaInfo)

** para el provider en el app.jsx hacemos lo siguiente
1) import { QueryClientProvider, QueryClient} from 'react-query'

2) const queryClient = new QueryClient();

3) Envolvemos la aplicacion en <QueryClientProvider client={queryClient}>

--------------------------------------- Portals ---------------------------------------
* sirve para renderizar componentes en otro lado de la app, los "transporta" independientemente de quien sea el padre

* ReactDOM.createPortal(child, container)
* El primer argumento (child) es cualquier hijo renderizable por React, como un elemento, cadena de caracteres o fragmento. El segundo argumento (container) es un elemento DOM.
* este metodo de createPorta esta dentro de la libreria react-dom
* en el return del html del componente q lo quiero hacer portal pongo:
return ReactDOM.createPortal(1,2)
1 ---> todo mi html del return del componente, normal como en cualquier otro
2 ---> de segundo parametro se le pasa getDocumentById con el div q tengamos en el index.html por fuera del id=root para q lo cargue ahi. Osea creariamos otro div vacio para esto

--------------------------------------- react lazy y suspense ---------------------------------------

* React.lazy facilita la división de código de una aplicación React a nivel de componente mediante importaciones dinámicas. Ejemplo

const MyComponente = lazy(() => import('./MyComponente'));

return (
  <>
    <MyComponente />
  </>
)

* sirve para cargar solo los modulos q necesitamos cuando los necesitemos. Es util en aplicaciones utiles
* Luego puede encargarse de los estados de carga cuando lo acopla con el componente Suspense
* el Suspense ayuda a que cuando este cargandose el js necesario te aparezca otro componente como cargando. Ejemplo

const MyComponente = lazy(() => import('./MyComponente'));

const loader = () => <p>Loading</p>;

const DetailsComponent = () => (
  <Suspense fallback={loader()}>
    <MyComponente />
  </Suspense>
)

* el fallback es donde se le pasa lo q va a mostrar cuando esta cargando el js que necesita
* para manejar los errores cargando informacion esta <ErrorBoundary /> ---> debemos wrapear el <Suspense /> con el ErrorBoundary para manejar los errores
* ErrorBoundary es un componente de clase normal q tiene un booleano y unas props para saber si hubo o no error y renderiza el error cuando termina la carga en caso de haber fallado

--------------------------------- ERROR BOUNDARY ------------------------------------------------------------------

* sirve para manejar los errores de la aplicacion. Estos no capturan errores de manejo de eventos, setTimeOut, renderizado del servidor, etc.
* los error boundary funcionan solo con catch de javascript
* se podria usar haciendo un HOC de boundary error, q se llame WithBoundaryError y lo wrapeamos al componente

--------------------------------- PRINCIPIOS SOLID ------------------------------------------------------------------

* Single responsibility principle ---> cada componente debe tener una sola tarea. Para esto usamos CustomHooks
* open close principle ---> cada entidad q tengamos deben estar abiertas para extender y cerradas para modificar. Osea tendriamos q tener un componente q no se toque y retocarlo de afuera para agregarle funcionalidades. Para esto usamos los children
* liskov ---> cada prop, deberia poder intercambiarse por una prop o metodo del elemento q lo hereda. Osea el componente padre y el hijo deben tener props con los mismos nombre y q hagan las cosas, por si algun dia queres cambiarlo no te daria problema de funcionalidad
* interface segregation principle ---> los clientes no deben depender de interfaces q no necesitan. Solo le tenemos q pasar a los componentes las cosas q necesitan, no todo el objeto data por ejemplo. Hacer el pasaje de solo lo q necesita
* dependency inversion principle ---> los componentes deben depender de abstracciones y no de implementaciones. Q haya parametros, no dejar nada fijo por ejemplo la url del fetch y poner parametro q se llame url

--------------------------------- INTERSECTION OBSERVER ------------------------------------------------------------------

* La API Intersection Observer le permite configurar una función callback que es llamada cuando alguna de las siguientes circunstancias ocurren:
* Un elemento target intersecta ya sea al viewport del dispositivo o un elemento especificado. Ese elemento especificado es llamado el elemento root o root a los propósitos de la API Intersection Observer.
* La primera vez que se pide inicialmente al observador que observe un elemento target.
* Ejemplo
** Cree el intersection observer llamando a su constructor y pasándole una función callback para que se ejecute cuando se cruce un umbral (threshold) en una u otra dirección:

  let options = {
    root: document.querySelector('#scrollArea'),
    rootMargin: '0px',
    threshold: 1.0
  }

  let observer = new IntersectionObserver(callback, options);
* opciones:
* root ---> el elemento q es usado como viewporta
* rootMargin ---> margen al rededor del elemento root
* threshold ---> Es un número o un array de números que indican a que porcentaje de visibilidad del elemento target, la función callback del observer debería ser ejecutada. Si usted quiere que se detecte cuando la visibilidad pasa la marca del 50%, debería usar un valor de 0.5. Si quiere ejecutar la función callback cada vez que la visibilidad pase otro 25%, usted debería especificar el array [0, 0.25, 0.5, 0.75, 1]. El valor por defecto es 0 (lo que significa que tan pronto como un píxel sea visible, la función callback será ejecutada). Un valor de 1.0 significa que el umbral no se considera pasado hasta que todos los pixels son visibles.

--------------------------------- DOCUMENTACION REACT -----------------------------------------------

********************************* RENDERIZADO DE ELEMENTOS *********************************

* el div del html q tiene el id='root' es el nodo raiz. Porque todo lo que esté dentro de él será manejado por React DOM.
* En la practica se suele tener solo un nodo raiz, pero es posible tener todos los que se quieran. Para crear uno primero debemos pasarlo por  ReactDOM.createRoot() y luego por el .render(). Ejemplo:

  const root = ReactDOM.createRoot(
    document.getElementById('root')
  );
  const element = <h1>Hello, world</h1>;
  root.render(element);

* Los elementos de React son INMUTABLES. Una vez creados no se pueden cambiar sus atributos e hijos. La unica manera de actualizarlo es pasar al elemento por el .render() nuevamente y creando un nuevo elemento
* React solo actualiza lo que es necesario. React por detras compara los elementos anteriores y sus hijos y solo aplica actualizaciones en el dom q son necesarias para llegar al nuevo render. Por ejemplo si cambia el texto no modifica una etiqueta <p> sino solo el texto q esta adentro.

********************************* COMPONENTES Y PROPIEDADES *********************************

* Los componentes son como las funciones de JavaScript. Aceptan entradas arbitrarias (llamadas “props”) y retornan elementos de React que describen lo que debe aparecer en la pantalla.
* Existen dos tipos de componentes: de clase y funcionales
* Los programadores son quienes pueden crear componentes y pasarle propiedades q este recibira mediante un objeto llamado props por parametros en los componentes funcionales
* Los nombres de los componentes deben empezar siempre en mayuscula. Si le ponemos una letra minuscula los trata como una etiqueta del DOM
* si se hace una migracion hacia react es conveniente empezar desde los componentes menores y ir escalando la cima. Desde un button hasta el componente App q seria el mayor
* Es conveniente hacer los componentes los mas chicos y genericos posible para asi poder reutilizarlos
* Nunca se deben modificar las props q se le pasan al componente. Estas funciones son llamadas puras y si le pasamos lo mismo siempre deberian devolver lo mismo. Para eso existen los state

********************************* ESTADO Y CICLO DE VIDA *********************************

* un state(estado) es como las props pero privada y controlada por el componente mismo
* Pasos a seguir para cambiar de un componente funcional a uno de clases:
1) Crear una clase ES6 con el mismo nombre que herede de React.Component.
2) Agregar un único método vacío llamado render().
3) Mover el cuerpo de la función al método render().
4) Reemplazar props con this.props en el cuerpo de render().
5) Borrar el resto de la declaración de la función ya vacía.

* agregar un state a un componente de clase:
1) en los lugares donde usemos le ponemos this.state
2) añadimos un constructor en la clase q asigue this.state a un objeto con las props q vamos a usar, y ademas le agregamos  super(props) en el constructor para que herede propiedades

* En una aplicacion grande es importante destruir o desmontar componentes para que no sea tan costosa y poco performante.
* en un componente de clase se pueden declarar metodos para cuando se monta o desmonta el componente. Para esto existen:
1)  componentDidMount() ---> se ejecuta cuando el componente se monto (parecido al use effect)
2) componentWillUnmount() ---> se ejecuta cuando el componente se desmonta

* se utiliza el this.setState() para actualizar los valores de los state en el componente de clase
* las actualizaciones del estado con setState pueden ser asincronicas. Es conveniente agrupar el setState lo maximo posible para que sea mas performante.
* Para modificarlo en el setState() es conveniente agarrar el estado previo y las props en vez de usar el mismo state (this.state.laVaribleQSea)
* en react los datos siempre fluyen de padres a hijos. El flujo es unidireccional

********************************* MANEJANDO EVENTOS ******************************************************

* es muy similar a manejar eventos en el dom. Las diferencias son:
1) Los eventos de React se nombran usando camelCase, en vez de minúsculas.
2) Con JSX pasas una función como el manejador del evento, en vez de un string.
* en react no se puede retornar false para prevenir el comportamiento por defecto. Se debe llamar explicitamente a preventDefault()
* si al onclick le pasamos una funcion flecha q se ejecute esto deberia hacerse si se ejecuta el evento en el mismo componente. No pasar funciones flechas como prop a hijos pq puede renderizarse de nuevo el componente

********************************* RENDERIZADO CONDICIONAL ************************************************

* Si queremos renderizar condicionalmente con un if nomas debemos usar && y retornar lo que queremos sin la palabra return
* Esto funciona porque en JavaScript, true && expresión siempre evalúa a expresión, y false && expresión siempre evalúa a false.
* si renderizamos con if-else se puede usar un operador ternario condicion ? retorno si se cumple : retorno si no se cumple
* si queres que un componente no se renderice en algun caso. Ponemos un if ante de arrancar la parte del html a renderizar y retornamos null. Esto hace q el componente no se renderice si se da esa condicion. Ejemplo:
  function WarningBanner(props) {
    if (!props.warn) {
      return null;
    }
    return (
      <div className="warning">
        Warning!
      </div>
    );
  }

********************************* LISTAS Y KEYS ********************************************************

* la key q le pasamos siempre es string. Es importante que sean valores unicos en esa lista. Es ideal no usar el indice para asignar keys pq puede generar problemas de rendimientos
* Las keys ayudan a React a identificar que ítems han cambiado, son agregados, o son eliminados.
* Al asignar un index a la key de la lista, si agregamos o eliminamos una el index en esa posicion no cambiaria aunque la informacion que tiene dentro si. Por lo cual podriamos estar mostrando informacion incorrecta
* Casos en los que se podria asignar el index como key:
1) la lista y los elementos son estáticos: no se calculan y no cambian;
2) los elementos de la lista no tienen identificadores;
3) la lista nunca se reordena ni se filtra.

********************************* COMPONENTES CONTROLADOS Y NO CONTROLADOS *********************************

* La diferencia entre los controlados (valores de los inputs manejados por react) y los componentes no controlados (valores controlados por el dom) es quien maneja los valores.
* Para tener un componente controlado ponemos el onChange y le asignamos a la variable del input el setState de ese input. Con esto logramos q React sea 'la fuente del a verdad' y el componente siempre este dirigido por el estado. Entonces en el value le asignamos el state y en el onchagen el setState de ese state.
* Esto es util si queremos pasar la informacion del input a otros elementos de la interfaz de usuario o si queremos reiniciarlo desde otros manejadores de eventos
** OBS en las etiquetas select se le puede pasar en el value un array con las opciones
* El input de tipo file solo es de lectura por lo tanto es un componente no controlado
* Si trabajamos con mas de 1 input al mismo tiempo es conveniente a cada input asignarle un name y hacer q el name sea igual al value. Entonces en el onchange hacemos una funcion q tome el name y le asigne el nuevo value para asi tener una funcion reutilizable
* si a un input le damos el value en null o undefined hace q no se pueda modificar

********************************* LEVANTANDO EL STATE ****************************************************

* cuando vemos que 2 componentes estan modificando el mismo dato, debemos levantas el state local de cada uno y llevarlo al componente compartido en donde se invocan esos dos para asi tengan el mismo estado pasado por props.

********************************* COMPOSICION VS HERENCIA ************************************************

* Siempre es mejor una composicion a una herencia. Por eso es importante cuando no sabemos q vamos a poner adentro de la caja usar la propiedad children q viene por defecto en las props

********************************* ACCESIBILIDAD **********************************************************

* Una practica para esto es usar etiquetas semanticas de html, labels con htmlFor='nombre del campo descriptivo', fragments
* cuando no necesitas pasar ninguna prop en el fragment se puede pasar <></> en ves de asi <Fragment></Fragment>
* el for en una etiequeta html se pone en react como htmlFor
* se deben notificar los errores para que los entienda el usuario correctamente en los formularios
* <main> y <aside> para que pueda skipearse partes del html con el teclado
* tambien se debe poder acceder mediante el teclado a todas las funciones que se apreten cone l mouse. Ejemplo abrimos un modal y no podemos aceder a el mediante el teclado
* configuracion de la etiqueta title
* contraste de colores
* configuracion de idioma

********************************* SEPARACION DE CODIGO ****************************************************

* dividir tu codigo en varios archivos y cargar solo los que necesita el usuario ayuda mucho al rendimiento de la aplicacion
* Lo mejor para dividir el codigo es usar imports dinamicos. Si usas create react app ya viene implementado.
* La función React.lazy te deja renderizar un import dinámico como un componente regular. Ejemplo:
  // sin lazy
  import OtherComponent from './OtherComponent';
  // con lazy
  const OtherComponent = React.lazy(() => import('./OtherComponent'));

* El componente lazy debería entonces ser renderizado adentro de un componente Suspense, lo que nos permite mostrar algún contenido predeterminado (como un indicador de carga) mientras estamos esperando a que el componente lazy cargue.
* La prop fallback acepta cualquier elemento de React que quieras renderizar mientras esperas
* ojo con usar mucho fallback ya q puede generar problemas de experiencia de usuario al no tener nada para mostrar muestra el componente mas arriba disponible.
* Si la carga del nuevo componente falla podemos usar Error Boundary
* es una buena decision hacer la division de codigo en la parte de las rutas, para no alterar la experiencia de usuario. Esto es porque al cambiar de pagian el usuario esta acostumbrado a no interactuar hasta q cargue la nueva pagina.
* React.lazy actualmente solo admite exports tipo default. Si el módulo que desea importar utiliza exports con nombre, puede crear un módulo intermedio que lo vuelva a exportar como default


LLEGUE HASTA ACA
https://es.reactjs.org/docs/context.html



Dato interesante: Para hacer un loading en un state hacemos un fetch y en el .finally le cambiamos el loader a false,

**** ESTUDIAR ---------> imports dinamicos
