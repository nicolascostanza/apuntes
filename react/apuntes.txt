R--------------------------------------- useContext ---------------------------------------
1) asignamos a una variable el createContext y la exportamos para usarla donde querramos
export const userContext = React.createContext();
2) Agarramos ese userContext como un componente y encerramos toda nuestra app con el componente.Provider. Ademas le damos un value con el store q vamos a tener para almacenar datos q pueda leer cualquier coponente dentro. Esta logica del context es ideal sacarla a un archivo aparte con funciones para manejar esa informacion etc.
return (
  <userContext.Provider value={storeConDatosQVamosAProveer}>
    <div></div>
    <img />
  </userContext.Provider>
)
3) En los componentes donde queremos leer esa data hacemos useContext
const dataDelContext = useContext(NombreDelContextoQVamosALeer)

--------------------------------------- useRef ---------------------------------------
* Use ref crea un objeto. En el cual tiene una key q se llama current q tiene el valor actual. Sirve para mantener un valor al menos que le indiquemos q lo cambie
* Seria como una variable que no se va a perder entre cambios de estados. Osea es una variable q se modifica pero no cambia en el render de la aplicacion, no va a volver a renderizarla.
* Si nosotros cambiamos ese valor nuestra aplicacion NO SE VUELVE A RENDERIZAR.
* Tambien podemos referenciar elementos del dom. En el elemento html ponemos la prop ref={variable q le ponemoss useRef()}

1) definimos el useRef
const name = useRef('valorPorDefecto')
2) luego en los lugares que queremos le modificamos el valor. Al ser un objeto, debemos acceder al a propiedad current
name.current = 'Cambio el nombre';

--------------------------------------- useMemo ---------------------------------------
* memorizamos un valor y solo si una dependencia q le pasamos en el segundo parametro cambia volvemos a memorizar el nuevo valor
* Sirve para no hacer renders innecesarios. Ejemplo

const prueba = useMemo(() => {}, [])
el primer parametro se hace la logica q usamos para calcular, el array q esta en el 2do parametro del useMemo es un array de dependencias. Son los elementos q si cambian se vuelve a ejecutar la funcion del primer parametro

--------------------------------------- useCallback ---------------------------------------
* memorizamos una funcion para q no se vuelvan a generar y a ejecutar en cada render, solo cuando cambien las dependencias q le pasamos en el array que esta en el segundo parametro del hook.
* La diferencia con useMemo es q el useCallback te devuelve la funcion memorizada, en cambio el useMemo te devuelve el valor calculado de la funcion. El callback, al devolvernos la funcion, podemos ejecutarla. Ejemplo

const ejemplo = useCallback(() => {}, [])

--------------------------------------- useReducer ---------------------------------------
* seria lo mismo q un useState pero si tiene muchas variantes para cambiar es preferible un useReducer. Serian para estados mas complejos. Tiene un state un dispatch q despacha las acciones y del otro lado le pasamos, el reducer y el inicial state. Ejemplo
import {useReducer} from 'react';

const initialState = {
  contador = 10
}

interface actionType { type: 'incrementar' | 'decrementar'}

const contadorReducer = (state: typeof initialState, action: actionType) => {
  switch( action.type) {
    case 'incrementar':
      return {
        ...state,
        contador: state.contador + 1
      }
    case 'decrementar':
      return {
        ...state,
        contador: state.contador - 1
      }
    default:
      return state;
  }
}

** luego en el componente o mas abajo definimos el reducer
** el init sirve por si tarda en cargar la data q trae q muestre algo
** y luego usamos el dispatch y le mandamos las acciones
** el action es un objeto q mandas el nombre de la action y el payload con la data q podes usar
** ademas en contadorState podemos desestructurar y traernos { contador }

const [contadorState, dispatch] = useReducer(contadorReducer, initialState, init)

() => dispatch({type: 'incrementar'})


--------------------------------------- useParams ---------------------------------------
* se importa de la libreria react-router. Sirve para extraer los parametros de la url. En el siguiente ejemplo en la constante params tenemos un objeto con cada param de la url con su nombre y valor. Ejemplo

const params = useParams()

--------------------------------------- useLocation ---------------------------------------
* se importa de la libreria react-router. la constante del ejemplo es un objeto con propiedades especificas.

const location = useLocation()

* Pathname, que seria luego de wwww.nombrepag.com lo q le sigue en la ruta de la url.
* Search son los query params q le pasamos a la url

Ejemplo para obtener las querys de forma facil.
const {search} = useLocation();
const query = new URLSearchParams(search);

// obtiene la query del precio q pasariamos
const price = query.get('price');

--------------------------------------- useHistory ---------------------------------------
* se importa de la libreria react-router. Te devuelve un objeto con varias propiedades. Este hook tiene tambien dentro el useLocation
* push, es una funcion q le pasas un string de parametro con el path al cual queres ir y te envia ahi
* goFoward, para ir adelante en el historial
* goBack, para ir atras en el historial
* go, para que vaya a alguna pagina
const history = useHistory()

--------------------------------------- useNavigate ---------------------------------------
* se importa de la libreria react-router. Es una funcion q le pasas el path y te navea a esa ruta.

const navigate = useNavigate()
navigate('/home')

--------------------------------------- react router dom -----------------------------------
* Link ----> es un componente q tiene esta libreria, es como una etiqueta <a> pero q tiene toda la logica que necesitamos. Para el href se reemplaza con un to={A donde nos redirije}. No puede usarse por fuera de una etiqueta Route
* BrowserRouter ---> tiene toda la api del history. Debemos encerrar las etiquetas link dentro de un BrowserRouter
* Route ---> Es un componente q le pasas path='Path al que vas a ir' y wrapeas el componente q vas a renderizar. Debemos pasarle el exact para q la ruta sea exacta en el path y renderice lo q queremos.
* Switch ---> hace q solo se quede con el primero q coincida. Con esta etiqueta wrapeamos las etiquetas Route

Ejemplo:

<BrowserRouter>
  <Link to='/contacto'>Contacto</Link>
  <Switch>
    <Route path='/contacto>
      <ContactPage />
    </Route>
  </Switch>
</BrowserRouter>

--------------------------------------- HOC ---------------------------------------
* los high order component son las funciones que tienen la capacidad de recibir un componente como parametro y retornar un componente nuevo
* se recomienda q al hacer estas funciones inicien con la palabra with y seguida de algo q represente
* recibe un componente hace logica y retorna el mismo componente mejorado con la logica o otro. Ejemplo
* son como los customHooks pero de antes

const withConsoleLog = (Component, config?) => {
  const WrappedComponent = () => {
    // ACA HACEMOS LA LOGICA
    return <Component />
  }

  return <WrappedComponent />
}

** despues wrapeamos nusetro componente con este HOC. Ejemplo
export default withConsoleLog(App);

--------------------------------------- Promesas ---------------------------------------
* un callback es una funcion que pasas por parametro para q la ejecute cuando termine la funcion y eso sea lo que retorna
* el constructor new Promises recibe una funcion con dos parametros q son resolve y reject
* entonces en una funcion nos quedaria

const funcWithPromises = (a, b ) => {
  const resultado = a + b;
  return new Promises((resolve, reject) => {
    //hago cosas y retorno lo q quiero
    resolve(funcionQueLePasoCuandoTerminaBien)
    reject(funcionQueLePasoCuandoTerminaMal)
  })
}

** el .then lo ejecuta  con el resolve y el .catch lo ejecuta con el reject
funcWithPromises(1, 3)
  .then((res) => console.log(res))
  .catch((res) => console.log('Errorrrrr'))


--------------------------------------- Promise All ---------------------------------------
* Promise.all ---> es un array de promesas q se hacen en simultaneo entonces acortan el tiempo de espera. Si falla una, va al catch directo
* Promise.allSettled devuelve un array en los q vas a poder saber si una de las promesas fallo o no. Siempre resuelve

Promise.all([
  ...array con las promesas
]).then((response) => console.log(response))
.catch(() => console.log('errrror'))

Promise.allSettled([
  ...array con las promesas
]).then((values) => console.log('aca tenemos un array con cada promesa y errores o estado', values))
.catch(() => console.log('errrror'))

--------------------------------------- React Query ---------------------------------------
* sirve para las peticiones
* necesita un provider
* podemos importar ReactQueryDevtools q sirve para debuggear las request

const { data, status } = useQuery('ClaveQueRepresenteLoQueLePasamos', FuncionQueSeEjecutaCuandoQueremosLaInfo)

** para el provider en el app.jsx hacemos lo siguiente
1) import { QueryClientProvider, QueryClient} from 'react-query'

2) const queryClient = new QueryClient();

3) Envolvemos la aplicacion en <QueryClientProvider client={queryClient}>

--------------------------------------- Portals ---------------------------------------
* sirve para renderizar componentes en otro lado de la app, los "transporta" independientemente de quien sea el padre

* ReactDOM.createPortal(child, container)
* El primer argumento (child) es cualquier hijo renderizable por React, como un elemento, cadena de caracteres o fragmento. El segundo argumento (container) es un elemento DOM.
* este metodo de createPorta esta dentro de la libreria react-dom
* en el return del html del componente q lo quiero hacer portal pongo:
return ReactDOM.createPortal(1,2)
1 ---> todo mi html del return del componente, normal como en cualquier otro
2 ---> de segundo parametro se le pasa getDocumentById con el div q tengamos en el index.html por fuera del id=root para q lo cargue ahi. Osea creariamos otro div vacio para esto

--------------------------------------- react lazy y suspense ---------------------------------------

* React.lazy facilita la división de código de una aplicación React a nivel de componente mediante importaciones dinámicas. Ejemplo

const MyComponente = lazy(() => import('./MyComponente'));

return (
  <>
    <MyComponente />
  </>
)

* sirve para cargar solo los modulos q necesitamos cuando los necesitemos. Es util en aplicaciones utiles
* Luego puede encargarse de los estados de carga cuando lo acopla con el componente Suspense
* el Suspense ayuda a que cuando este cargandose el js necesario te aparezca otro componente como cargando. Ejemplo

const MyComponente = lazy(() => import('./MyComponente'));

const loader = () => <p>Loading</p>;

const DetailsComponent = () => (
  <Suspense fallback={loader()}>
    <MyComponente />
  </Suspense>
)

* el fallback es donde se le pasa lo q va a mostrar cuando esta cargando el js que necesita
* para manejar los errores cargando informacion esta <ErrorBoundary /> ---> debemos wrapear el <Suspense /> con el ErrorBoundary para manejar los errores
* ErrorBoundary es un componente de clase normal q tiene un booleano y unas props para saber si hubo o no error y renderiza el error cuando termina la carga en caso de haber fallado

--------------------------------- ERROR BOUNDARY ------------------------------------------------------------------

* sirve para manejar los errores de la aplicacion. Estos no capturan errores de manejo de eventos, setTimeOut, renderizado del servidor, etc.
* los error boundary funcionan solo con catch de javascript
* se podria usar haciendo un HOC de boundary error, q se llame WithBoundaryError y lo wrapeamos al componente

--------------------------------- PRINCIPIOS SOLID ------------------------------------------------------------------

* Single responsibility principle ---> cada componente debe tener una sola tarea. Para esto usamos CustomHooks
* open close principle ---> cada entidad q tengamos deben estar abiertas para extender y cerradas para modificar. Osea tendriamos q tener un componente q no se toque y retocarlo de afuera para agregarle funcionalidades. Para esto usamos los children
* liskov ---> cada prop, deberia poder intercambiarse por una prop o metodo del elemento q lo hereda. Osea el componente padre y el hijo deben tener props con los mismos nombre y q hagan las cosas, por si algun dia queres cambiarlo no te daria problema de funcionalidad
* interface segregation principle ---> los clientes no deben depender de interfaces q no necesitan. Solo le tenemos q pasar a los componentes las cosas q necesitan, no todo el objeto data por ejemplo. Hacer el pasaje de solo lo q necesita
* dependency inversion principle ---> los componentes deben depender de abstracciones y no de implementaciones. Q haya parametros, no dejar nada fijo por ejemplo la url del fetch y poner parametro q se llame url

--------------------------------- INTERSECTION OBSERVER ------------------------------------------------------------------

* La API Intersection Observer le permite configurar una función callback que es llamada cuando alguna de las siguientes circunstancias ocurren:
* Un elemento target intersecta ya sea al viewport del dispositivo o un elemento especificado. Ese elemento especificado es llamado el elemento root o root a los propósitos de la API Intersection Observer.
* La primera vez que se pide inicialmente al observador que observe un elemento target.
* Ejemplo
** Cree el intersection observer llamando a su constructor y pasándole una función callback para que se ejecute cuando se cruce un umbral (threshold) en una u otra dirección:

  let options = {
    root: document.querySelector('#scrollArea'),
    rootMargin: '0px',
    threshold: 1.0
  }

  let observer = new IntersectionObserver(callback, options);
* opciones:
* root ---> el elemento q es usado como viewporta
* rootMargin ---> margen al rededor del elemento root
* threshold ---> Es un número o un array de números que indican a que porcentaje de visibilidad del elemento target, la función callback del observer debería ser ejecutada. Si usted quiere que se detecte cuando la visibilidad pasa la marca del 50%, debería usar un valor de 0.5. Si quiere ejecutar la función callback cada vez que la visibilidad pase otro 25%, usted debería especificar el array [0, 0.25, 0.5, 0.75, 1]. El valor por defecto es 0 (lo que significa que tan pronto como un píxel sea visible, la función callback será ejecutada). Un valor de 1.0 significa que el umbral no se considera pasado hasta que todos los pixels son visibles.


Para hacer un loading en un state hacemos un fetch y en el .finally le cambiamos el loader a false,
 ESTUDIAR EL OBSERVER DE JS
